import axios from "axios";
import db from "../db";

/**
 * Fetch ONE pending symptom report with animal data
 */
async function fetchPendingReport() {
  const rows = await db("symptom_reports as sr")
    .join("animals as a", "sr.animal_id", "a.id")
    .select(
      "sr.id as report_id",
      "sr.symptom_text",
      "sr.status",
      "a.species as animal_type",
      "a.age",
      "a.weight"
    )
    .where("sr.status", "received")
    .orderBy("sr.created_at", "asc")
    .limit(1);

  return rows[0];
}

/**
 * Convert symptom_text → string[]
 */
function parseSymptoms(symptomText: string | null): string[] {
  if (!symptomText) return [];

  return symptomText
    .split(",")
    .map(s => s.trim().toLowerCase())
    .filter(Boolean);
}

/**
 * Main worker execution
 */
async function runOnce() {
  const report = await fetchPendingReport();

  if (!report) {
    console.log("[WORKER] No pending reports");
    return;
  }

  const reportId = report.report_id;
  console.log("[WORKER] Predicting for report:", reportId);

  if (report.animal_type === 'buffalo') {
    throw new Error('Unsupported animal type');
  }

  const symptoms = parseSymptoms(report.symptom_text);

  /**
   * RAW payload → send free-text to the ML NLP endpoint which will
   * extract features and call the model (ml service v2 `/predict_from_text`).
   */
  const mlPayload = {
    animal: report.animal_type, // cow | goat | sheep | buffalo
    symptom_text: report.symptom_text ?? "",
    age: report.age ?? 0,
    body_temperature: 0 // not stored yet
  };

  try {
    const mlResp = await axios.post(
      "http://localhost:8001/predict_from_text",
      mlPayload,
      { timeout: 10000 }
    );

    const data = mlResp.data;
    console.log("[WORKER] ML response:", data);

    // Save diagnosis
    await db("diagnoses").insert({
      report_id: reportId,
      predicted_label: data.predicted_label,
      confidence: data.confidence,
      recommended_actions: JSON.stringify({
        note: "Auto-generated by AI diagnostic model"
      }),
      model_version: null
    });

    // Save audit log
    await db("prediction_logs").insert({
      report_id: reportId,
      features: JSON.stringify(mlPayload),
      raw_output: JSON.stringify(data),
      model_version: null
    });

    // Update report status
    await db("symptom_reports")
      .where({ id: reportId })
      .update({ status: "predicted" });

    console.log("[WORKER] Prediction saved for report:", reportId);

  } catch (err: any) {
    console.error("[WORKER] Prediction failed:", err?.message || err);

    await db("symptom_reports")
      .where({ id: reportId })
      .update({ status: "error" });
  }
}

/**
 * Run once (cron / manual / worker)
 */
if (require.main === module) {
  console.log("[WORKER] Starting...");
  (async () => {
    try {
      await runOnce();
      console.log("[WORKER] Done");
    } catch (err) {
      console.error("[WORKER] Fatal error:", err);
    }
    process.exit(0);
  })();
}
